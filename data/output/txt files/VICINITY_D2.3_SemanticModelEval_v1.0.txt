Introduction
The VICINITY interoperability approach relies on ontologies (i.e., semantic data models) that will be exploited throughout the VICINITY infrastructure. Such ontologies, which are developed as an ontology network, are explained in the VICINITY deliverable "D2.2 Detailed Specification of the Semantic Model" and should be evaluated regarding several criteria before they are released. The VICINITY ontology network consists of five ontologies so far, namely the VICINITY Core (Core), the Web of Things (WoT), the WoT mappings (Mappings), the VICINITY Adapters (Adapters), and the Ontology model for datatypes (Datatypes) ontologies. The Core ontology represents the information needed to exchange IoT descriptor data between peers through the VICINITY platform; this ontology is being created by following a cross-domain approach and implements requirements from different domain experts. The WoT ontology aims to model the Web of Things domain. The Mappings ontology represents the mechanism for accessing the values provided by web things in the VICINITY platform. The Adapters ontology aims to model all the different types of devices and properties that can be defined in the VICINITY platform. Finally, the Datatypes ontology aims to model the required and provided datatypes that are used in the interaction patterns of the platform. More information about these ontologies is available in the VICINITY ontology portal. 1 Figure Figure 2 Ontology development methodology
Before publishing a release version of the ontology, during the ontology implementation the ontology should be evaluated. This evaluation process, as it is described in In this document, the evaluation process of the VICINITY ontologies was carried out following the following criteria: (1) validation regarding the model, (2) verification regarding their ontological requirements, (3) validation regarding pilot data, and (4) verification regarding IoT standards.The goal of this deliverable is to detail how the developed VICINITY ontologies are validated to assure the users that they are correctly built, complete, and ready to be used.The rest of this deliverable is structured as follows:• Section 2 provides the validation of the ontologies regarding modelling issues.• Section 3 is devoted to validation of the ontologies regarding their ontological requirements.• Section 4 describes the validation regarding the pilot data.• Section 5 is dedicated to the description of the validation regarding several IoT standards.• Section 6 provides some conclusions and future lines of work.Context within VICINITY
The D2. Objectives in Work Package 2 and Task 2.3
The objective of WP2 is to validate the ontologies and interfaces specified by the project and to contribute the results and experience to standardisation bodies. WP2 will define a semantic model for cross-domain IoT networks and demonstrate and validate it in real scenarios and will support the correlation between the proposed semantic model and existing IoT platforms and infrastructures. Finally, the evaluation of demonstrators will be used to validate the model and to produce the corresponding standardization recommendations. Within Task 2.3 the platform and the semantic model will be validated in real life situations with inputs from the project demonstration sites and that will serve as the basis for recommendations, amendments and extensions to standardization.Ontology evaluation of technical quality
Along this section the evaluation of technical quality process of the VICINITY ontology network is described. This evaluation includes the detection of inconsistencies in the ontologies by using semantic reasoners and the detection of modelling errors by using the tool OOPS!.Semantic reasoners
To ensure the quality of ontologies, there is a need for dealing with the inconsistency and uncertainty in the ontologies. Therefore, once an ontology is developed, it is needed to assure that there are not inconsistencies in it. An inconsistency refers to a severe error which implies that some of the classes in the ontology cannot have instances (OWL individuals), and no useful knowledge can be inferred from the ontology. The inconsistency will result in false semantic understanding and knowledge representation.For this reason, semantic reasoners should be used during the ontology development process. A semantic reasoner is a program that infers logical consequences from a set of explicitly asserted facts or axioms and typically provides automated support for reasoning tasks such as classification, debugging and querying, in order to identify inconsistencies in the analysed ontology.For the VICINITY project, the HermiTOOPS!
In order to identify if the ontologies are correctly built, it was decided to check whether there are modelling issues by using the OOPS! (OntOlogy Pitfall Scanner!) tool Figure 12
annotations and naming conventions and they will be corrected in future releases of the ontology network, together with the unconnected elements found in the ontology network. Regarding the pitfalls related to "Inverse relationships not explicitly declared", the ontology developers will analyse each potential inverse relationship to add those considered necessary without adding too much overhead to the ontology.  Validation with regards to ontological requirements
The validation of ontologies before the online publication is a crucial part in the ontology development process, since it will guarantee that all the requirements asked by the domain experts are satisfied by the ontology after it is released online. In VICINITY, the testing process described in Testing method
The testing process followed in VICINITY is based on three activities, i.e., test design, test implementation and test execution. In the test design activity, the knowledge intended to be produced by every requirement is identified, e.g., from the requirement "A device can have a status" is expected a relation between two concepts in the ontology. To formalize such knowledge into a test case a collection of test expressions is used according to the requirements behaviour. During the test implementation activity such test expressions are implemented in order to be able to execute them on our ontologies to validate the associated requirement. The implementation of the test cases is based on the analysis of the behaviour of the ontology in different situations to verify that certain knowledge is modelled in the ontology, rather than simply checking the presence or absence of axioms using semantic reasoners. This is because the use of semantic reasoners is not enough to validate if a requirement is satisfied.In addition to the testing activities, we propose an RDF vocabulary to store the generated test cases and to provide traceability between them and their associated requirements. Figure Test design
During this activity the desired behaviour, i.e., the knowledge intended to be produced by every requirement in an ontology, of each requirement is extracted. In order to carry out this extraction, we 15
provide a set of possible test expressions, extracted from the CORAL Corpus Test implementation
In order to implement the tests to verify if a desired behaviour is satisfied, a procedure is proposed. In this procedure the test design is formalized into a precondition, a set of auxiliary term declarations and a set of assertions to check the behaviour. The procedure to implement each test expression defined in Table The precondition is a SPARQL query which checks whether the terms involved in the ontology requirement are defined in the ontology. In order to execute the tests, these terms need to be declared in the ontology. Otherwise, the test fails, and the requirement is not satisfied. The axioms to declare auxiliary terms are a set of temporary axioms added to the ontology to declare the auxiliary terms needed to carry out the assertions. After the addition of these axioms the reasoner is executed and, in order to be able to check the behaviour, the ontology needs to be consistent. Finally, the assertions to check the behaviour are a set of pairs of axioms and expected results that represent different ontology scenarios. For each pair, the axiom is temporary added to the ontology to force a scenario, after which the reasoner is executed. The expected result determines if the ontology status after the addition (i.e., inconsistent ontology, unsatisfiable class or consistent ontology) is the expected one in case the requirement was satisfied. If all the status concurs with the expected status, then the requirement is satisfied.As an example, to check equivalence between two concepts (A EquivalentTo B), we define a set of auxiliary terms, i.e., the classes that complement A (⌐A) and B (⌐B). After their definition, we define a set of assertions that force the ontology to present unsatisfiable classes or inconsistencies. First, it is generated a class A' that is defined as a subclass of class B and ⌐A. If the ontology satisfies the requirement, this addition causes an unsatisfiable class due to the fact that the reasoner would infer that A' is subclass of A and ⌐A. Then, it is generated a class A' that is defined as a subclass of class A and ⌐B. If the ontology satisfies the requirement, this addition causes an unsatisfiable class due to the fact that the reasoner would infer that A' is subclass of B and ⌐B. The last assertion, generates a class A' that is defined as a subclass of class A and B. If the ontology satisfies the requirement, this assertion causes a consistent ontology due to the fact that there is no problem if A' is subclass of A and B.The output of this activity is an RDF document where the test cases are stored using the proposed vocabulary. In this vocabulary, each test case implementation stores the associated test design; the test preparation, which represents auxiliary terms declaration; and the corresponding test assertions.Test execution
Finally, the test execution activity consists in three steps, namely, the execution of the query which represents the preconditions, the addition of the axioms which declare the auxiliary terms, and the addition of the assertions. After the addition of each axiom, the reasoner is executed to report the status of the ontology. The addition of the auxiliary axioms needs to always lead to a consistent ontology. In the case of the assertions, the agreement between the reasoner status after the addition of all the axioms and the status indicated in the test implementation determines whether the ontology satisfies the desired behaviour. We distinguish four possible results: § Undefined terms, if the ontology does not pass the preconditions.§ Passed, if the ontology passes the preconditions and the results of the assertions are the expected ones. § Absent relation, if the ontology passes the preconditions, the results of the assertions are not the expected ones, but the addition of the requirements would not lead to an inconsistency in the ontology. § Conflict, if the ontology passes the preconditions, the results of the assertions are not the expected ones and the addition of the requirements would lead to an inconsistency in the ontology.It is worth mentioning that during this activity it is also carried out a mapping between the term identified in the test implementation and the actual term in the ontology where the ontology is going D2.3 Evaluation of the semantic model in real world scenarios 17 to be executed. The mapping at this stage of the testing process allows to execute the same tests on multiple ontologies. Figure As an example, if we want to check equivalence between two classes Sensor and Actuator, the test will result in undefined terms if the ontology does not define a class named Sensor or a class named Actuator. Additionally, the test will result in an absent relation if the ontology defines the classes named Sensor and Actuator but does not define any relation between them, and the test will result in a conflict if the defined relation in the ontology between the classes Sensor and Actuator is a disjoint instead of an equivalence. However, if the ontology to be tested defines an equivalence relation between the classes Sensor and Actuator, then the test will be passed. This testing process is supported by the tool Themis, which is a web application that is available online. 3 As it is shown in Figure The interface also shows the results for each of the test expressions. The possible results are the same as the results described in the previous section, namely, undefined terms, passed, absent relation, and conflict. Figure 3 http://themis.linkeddata.es/  Themis also allows to export the test expressions added in the interface as RDF files, which can be uploaded online to reuse them over the same or other ontologies. Table Table 3: Summary of requirements categorization for the VICINITY ontology network
From the set of ontological requirements defined for each ontology, test cases were extracted in order to validate the ontology. Such test cases were generated by using the test expression catalogue provided in Section 3. Each ontological requirement is translated to one or more test expressions, selecting the more appropriate ones from the test catalogue. Several test cases can be related to the same requirement. Table It is worth mentioning that the test suites, i.e., the sets of test cases associated to each ontology, were exported to RDF files and uploaded to the VICINITY ontology portal. These online RDF files can be reused in future releases of the ontology to assure that all the previous requirements are still satisfied. Ontological requirements
21
The test cases are stored using the Verification Test Case ontology 6 to describe their properties. Each RDF file includes, in addition to the set of test cases, the provenance of the test suite, i.e., the ontology from which the test cases were extracted. Each test case is also linked to the URI of the associated requirement and can also include the competency question of such associated requirement in order to improve the readability of the test case.Once all the tests were defined, Themis was executed during the ontology development process in order to identify if there are tests that are not passed by the ontology. Table 22
Validation with regards to pilots' dataIn the context of the VICINITY project we have devised an ontology that defines how data must be modelled. Nevertheless, the data used in the platform can use terms from our ontology or even use other terms that are not defined in our ontology; in that cases it is relevant to check whether the terms are made up or actually the ones from the specified ontology. In addition, there are other facts that should be checked or quantified relaying on the data.Figure Figure Bearing in mind these types of requirements we have devised a validation system called Things Monitor. Our system aims at checking and validating a set of requirements provided by an expert. In addition, we have implemented a dashboard manager that shows the results of all the requirements established and maintains the privacy restrictions of the VICINITY platform by implementing an authentication system. Methodology for validating VICINITY
To validate VICINITY, on the one hand, we provided a set of general requirements that the platform must fulfil and, on the other hand, we provided a set of requirements that the data of each account in VICINITY must meet; for instance, the accounts of the pilots. The requirements provided are namely for visualisation.For the overview of the platform we have the following requirements: § Evolution of Things in VICINITY: is meant to display how the platform evolves showing the Things registered over time, the adapters, services, and other elements related to those Things. § Things in VICINITY: is meant to display the number of Things registered in VICINITY, and from those, which are labelled as adapters or services, or on the contrary have a too generic type.In addition this requirement shows the number of Things that where correctly described in order to be used by the Semantic Interoperability services. § Things owned by an organisation: is meant to display for each account in the VICINITY platform the number of Things owned by such account. § Accessibility of interaction patterns: is meant to report the number of Things that are accessible, either to read or write. § Types of interaction patterns: is meant to report the type of interactions that the Things have, i.e., if they expose data (properties), trigger events (event), or an order can be written in the thing (actions). § Things with contextual information: is meant to report which Things were registered in the platform with contextual data, i.e., the building or building space where are located, their city or country, and their organisation. § Type of Things in VICINITY: is meant to display the type of Things, i.e., which kind of sensors and devices where registered in the platform. § Properties observed in VICINTIY: is meant to report the physical magnitudes observed by the IoT infrastructures registered in VICINTIY. § Organisations in VICINTIY: is meant to report the organisations registered, as well as the contracts in which they are involved to share or provide data.For the each of the accounts we have the following requirements: § Organisation's Things: is meant to report the number of Things registered by this organisation, and which of those where labelled with a type from the adapters ontology or as a service. In addition, this requirement report as well if the Things have the proper annotations so they can be used in the Semantic Interoperability Services. § Type of Things: is meant to report the type of things registered by this organisation. § Contracts held: is meant to report the contracts held by this organisation, either to expose data, or to read data. § Things with contextual information: is meant to report from the Things registered in the VICINITY belonging to this organisation in particular, how many have data about their location, i.e., building, building location, city, or country.To validate our requirements, we provided a manual to the partners so they can check whether their accounts meet the requirements. The validation is done by the partners, who need to check that their charts have the optimal values (specified in the manual). In this case, we have no strong constraints that can be evaluated as passed or failed; on the contrary the requirements encode desirable values that the platform should meet and due to this reason the validation depends as well by the partners.Things Monitor implementation
The Things Monitor is a VICINITY component, and due to this reason, is located in the GitHub of the project https://github.com/vicinityh2020/tmonitor; due to privacy issues, the manual is attached as a confidential document. Finally, the deployed version of the dashboard manager can be found at http://monitor.vicinity.linkeddata.es. However the access is not public due to privacy policies.Results of pilots' data validation
In this section we show the results of analysing how the pilots used the ontology. Our analysis is divided in several parts, first we are interested in know how many Things registered by the pilots where described using detailed types (from the Adapters ontology) instead of rather general (from the core).In addition to this we aimed at knowing how many of such Things where registered with the necessary data to be accessible through the semantic interoperability services. For this matter Figure In second place, we aimed at analyse the different interaction patters used by the registered things.We wished to know how many of them are either properties, actions, events or they were not labelled properly. In addition, we aimed at knowing how many properties have an observation from the ontology, and how many reported units of measure. On the one hand, Figure 28
Validation with regards to standardsIn addition to the validation of the requirements asked by the domain experts and users, the VICINITY ontology network was validated against the requirements of several IoT standards, in order to reuse concepts and patterns of well-known resources, namely: (1) the ETSI SAREF ontology Along this section the description of the method to carry out this coverage analysis is presented, in addition to the results analysis to check the coverage between the VICINITY ontologies and the already mentioned standards.Coverage analysis method
To carry out such coverage analysis, a systematic approach has been followed. First, the set of models is selected according to the domain to be analysed. Then, the ontological requirements of these selected standards are gathered. Afterwards, the requirements must be translated into test expressions, as it is described in Section 3, in order to be implemented and executed.As it is shown in Figure 29
Test results analysis Once the results of the testing method are available, i.e., which requirements are passed or not passed, an analysis of such results should be carried out. This analysis includes a set of steps that should be followed:1. Identify the topics of potential overlap between the input models and the ontology to be analysed, e.g., devices or users. 2. Identify for each pair input model and ontology: (1) the similarities in the requirements, This analysis of the results is accomplished in order to provide the users, domain experts and ontology developers with some indicators, including: § The number of requirements passed and not passed by the ontology, emphasizing which requirements generate a conflict between a standard and the ontology. § The concepts where there is an overlap between the input models and the ontology to be analysed. § The relation and identification of incompatibilities in the concepts where there is an overlap.These results can be used by these actors, i.e., users, domain experts and ontology developers, to provide feedback for the developed ontology, by means of requesting changes or by means of identifying inconsistencies between input models and the developed ontology. Moreover, it can also be used to identify mappings and potential terms for reuse.Coverage analysis infrastructure
For this coverage analysis we have also proposed Themis as the tool to execute the tests on the ontologies. Themis allows to load a test file and execute the test suite on multiple ontologies, as shown in Figure Once the report is generated, a table with more detailed information about the topics where there is an overlap can be generated. Such tables can include relations between the requirements, e.g., a requirement is contained in another or two requirements are incompatible, and the relation between concepts in several ontologies.Testing results
This section will describe the obtained testing results related to the conformance between the VICINITY ontology network and several IoT standards. Two analyses have been made: (1) the coverage of the VICINITY ontology network with respect to the IoT standards, and (2) the coverage of the IoT standards with respect to the VICINITY network.As previously mentioned, in addition to the VICINITY requirements asked by the partners, the VICINITY ontology network should satisfy the requirements of several standards in IoT, namely: (1) the SAREF ontology, (2) the SSN ontology, (3) OCF standards, (4) the oneM2M ontology, and (5) ISO/IEC 30141:2017. Therefore, the requirements related to these standards were collected, and the associated tests were defined by using the test expression catalogue as it is depicted in Table Tests results
Analysed
33
In addition to the coverage of the VICINITY ontologies regarding the IoT standards, it has also been analysed the coverage of the IoT standards regarding the VICINITY ontology network with the aim of identifying whether there is knowledge defined in VICINITY that is not defined in none of the standards, and to identify overlaps. Therefore, the test associated to the five ontologies that belong to the VICINITY network, i.e., the VICINITY Core (Core), the Web of Things (WoT), the WoT mappings (Mappings), the VICINITY Adapters (Adapters), and the Datatypes (Datatypes) ontologies, were executed on the IoT standards. Since to follow the coverage method process depicted in Figure First, Table However, there are some definitions of such concepts that are not included in both ontologies: § The relation between a device and a service, which is present in SAREF but not in VICINITY.§ The relation between a device and a commodity, which is present in SAREF but not in VICINITY.§ The category of devices, which is present in SAREF but not in VICINITY.§ The relation between a device and its functions, which is present in SAREF but not in VICINITY.§ The relation between a device and its owner, which is present in VICINITY but not in SAREF.D2.3 Evaluation of the semantic model in real world scenarios
40 § The relation between a thing and the interaction patterns, which is present in VICINITY but not in SAREF. § The relation between a thing and a thing and the security, which is present in VICINITY but not in SAREF. § The relation between a device and a spatial thing, which is present in VICINITY but not in SAREF.Moreover, from this table it is also possible to see that the conceptualization of the Profile concept defined in the SAREF ontology is different from what it is conceptualized as a Profile in the VICINITY ontologies, even though there is no logical incompatibility. Figure Table § The relation between a sensor and a system.However, there are some definitions of such concepts that are not included in both ontologies: § The relation of a procedure and its output, which is in the SSN ontology but not in the VICINITY ontologies. § The relation between a platform and its deployment, which is in the SSN ontology but not in the VICINITY ontologies. § The relation between a sensor and its stimulus, which is in the SSN ontology but not in the VICINITY ontologies. § The relation between an actuator and its actuations, which is in the SSN ontology but not in the VICINITY ontologies. § The relation between a procedure and its inputs, which is in the SSN ontology but not in the VICINITY ontologies. § The relation between a deployment and its platform, which is in the SSN ontology but not in the VICINITY ontologies. § The relation between a system and its procedure, which is in the SSN ontology but not in the VICINITY ontologies. § The relation between a systems and other systems, which is in the SSN ontology but not in the VICINITY ontologies. § The relation between a deployment and a property, which is in the SSN ontology but not in the VICINITY ontologies. § The relation between an actuation and a result, which is in the SSN ontology but not in the VICINITY ontologies. § The relation between a sensor and its observable properties, which is in the SSN ontology but not in the VICINITY ontologies. § The relation between security and things, which is in the VICINITY ontologies but not in the SSN ontology. § The relation between things and its interaction pattern, which is in the VICINITY ontologies but not in the SSN ontology. § The hierarchy of sensors, which is in the VICINITY ontologies but not in the SSN ontology.Even though these concepts, i.e., Thing, Procedure, Sensor, System, Procedure, Property, Feature of Interest, Actuator and Deployment are not completely aligned in VICINITY and SSN ontologies, it can be concluded that no incompatibilities were found. Additionally, it was also found that there are some D2.3 Evaluation of the semantic model in real world scenarios 46 absent relations in the ontology. This can be deduce from Table Figure Finally, Table However, there are some definitions of such concepts that are not included in both ontologies: § The relation between a device and a task, which is in the OneM2M ontology but not in the VICINITY ontology. § The relation between a device and a service, which is in the OneM2M ontology but not in the VICINIY ontology. § The relation between a thing and its properties, which is in the OneM2M ontology but not in the VICINIY ontology. § The attributes of a device, which is in the VICINITY ontologies but not in the OneM2M ontology. § The relation between a thing and its interaction patterns, which is in the VICINITY ontologies but not in the OneM2M ontology. § The relation between security and things, which is in the VICINITY ontologies but not in the OneM2M ontology. § The definition of a device profile, which is in the VICINITY ontologies but not in the OneM2M ontology.Moreover, from this table it is also possible to see that the conceptualization of the Device concept defined in the OneM2M ontology is different from what it is conceptualized as a Device in the VICINITY ontologies, since in OneM2M a device can be a physical o non-physical entity while in VICINITY a device can only be a physical entity. Figure D2.3 Evaluation of the semantic model in real world scenarios 50
Finally, Table Apart from checking that the developed ontologies satisfy all the project requirements, we also analyse how the VICINITY network is aligned with well-known IoT standards. From this coverage analysis we could conclude that, even though the VICINITY ontology network does not cover all the requirements in those standards, there are no inconsistencies between the standards and the VICINITY ontologies. This document also identifies the terms shared by the standards and the VICINITY ontologies. The coverage analysis also shows that VICINITY ontology network has partial conformance with the IoT standards, e.g., 14 requirements of ISO/IEC 30131:2017 or 8 requirements of SSN ontology were satisfied. However, this coverage analysis also shows that the VICINITY ontology network is out of scope of the analysed IoT standards, which is expected because the IoT standards are more generic than the VICINITY ontology network.In addition, we analysed the elements from the ontology used by the pilots to describe their infrastructures. As a result, we concluded that most of the data in vicinity is properly labelled with specific types from the Adapters ontology; pilots are mostly registering properties, but there are also some actions and events. The properties are correctly link to a physical magnitude observed by such property however units are not been used. In addition anther lack identified is the use of contextual data such as buildings, rooms, cities, or countries. Finally, the number of Things registered with mappings, and thus interoperable, is not very high. Therefore, although everything is suitable to be discovered, not all discoverable infrastructures will allow the semantic interoperability services to be accessed. This matter with the contextual data and the mappings is not necessarily something wrong, since depends on the level of privacy that the pilots want to specify in their Things.As future work, the minor pitfalls detected from the execution of OOPS! will be corrected, in order to improve the readability of the ontology. Additionally, a further analysis regarding whether more concepts should be reused or imported from the IoT standards will also be accomplished, in order to improve the conformance between the VICINITY ontology network and the analysed standards. Finally, as the VICINITY ontology network development methodology is iterative, the tests and their results will be updated in order to support the verification for such future versions.In summary, this deliverable presents the evaluation of the VICINITY ontology network. It is worth mentioning that during the project lifetime, new requirements could appear and the VICINITY ontology could be updated. All the results presented in this document related to the validation regarding the model and the verification regarding their ontological requirements are available online in the VICINITY ontology portalList of Figures
Figure 1
3 (D2. 3
Figure 3 :
Figure 4 :
Figure 5 :
Figure 6 :
of the semantic model in real world scenarios 19 Figure 7 :
Figure 8 :
Figure 10
Figure 10 :
D2. 3 Figure 11 :Figure 13 :
Figure 14 :D2. 3 Figure 15 :
Figure 16 :
Figure 17 :
Figure 18 :
D2. 3
Figure
D2. 3
Figureof the semantic model in real world scenarios 47 Table 13 :
D2. 3
Figure 23 :
D2. 3
D2. 3
Figure 1
Figure 3 :
Figure 4 :
Figure 5 :
Figure 6 :
Figure 7 :
Figure 8 :
Figure 9 :
Figure 13 :
Figure 14 :
Figure 15 :
Figure 16 :
Figure 17 :
Figure 18 :
Figure 20 :
Figure 22 :
Figure 21 :
D2. 3 Evaluation of the semantic model in real world scenarios 54 Figure 24 :
Table 1 : OOPS! Results for the VICINITY ontology network OOPS! results Ontology Critical Important Minor
Evaluation of the semantic model in real world scenarios
Table 2 : Supported test expressions Test goal Test expression syntax
D2.3 Evaluation of the semantic model in real world scenarios
Table 4 Tests executed for each VICINITY ontology
6 D2.3 Evaluation of the semantic model in real world scenarios
Table 5 : Summary of requirements information for the IoT standards
Table 6 : Summary of testing results for the IoT standards
10   Evaluation of the semantic model in real world scenarios
Table 7 : Testing results for SAREF ontology regarding to VICINITY requirements
Evaluation of the semantic model in real world scenarios 34Table 8 : Testing results for SAREF and VICINTY ontologies
Table 9 : Overlap between SAREF and VICINITY ontologies Adapter
VICINITY A smart oven is a type of device Adapter VICINITY A light switch is a type of device Adapter VICINITY The battery storage unit is a type of device Adapter VICINITY The photovoltaic panel is a type of device Adapter VICINITY The power meter is a type of device Adapter VICINITY A battery storage unit is a type of device Adapter VICINITY A photovoltaic panel is a type of device Device SAREF A device can be characterized by a profileTests results Analysed standard Total number of tests Number of test with undefined terms result Number of test with passed result Number of test with conflict result Number of test with absent relation result Relevant concepts
Table 10 : Testing results for W3C SSN ontology regarding VICINITY requirements
Tests results Analysed standard Total number of tests Number of test with undefined terms result
Evaluation of the semantic model in real world scenarios 43 Table 12: Overlap between the SSN and VICINITY ontologies
Table 14 : Testing results for oneM2M and VICINITY ontologies
Tests results Analysed standard Total number of tests Number of test with undefined terms result Number of test with passed result Number of test with conflict result Number of test with absent relation result Relevant concepts
Table 16 : Overview of the number of VICINITY requirements satisfied by each IoT standard Table 17: Overview of the number of the IoT standards' requirements satisfied by the VICINITY ontology network
18 Tests results Standard Number of VICINITY requirements passed Percentage of VICINITY requirements passed
Table 1 :
Table 2 :
Table 3 :
Table 5 :
Table 6 :
Table 7 :
Table 8 :
Table 9 :
http://www.hermit-reasoner.com/See https://github.com/mariapoveda/wot-ontology/issues/5 for the discussion of the deletion of the WoT interface term.See http://vicinity.iot.linkeddata.es/vicinity/testing.html for the online version of the VICINITY ontologies requirements.http://www.w3.org/ns/ssnhttps://openconnectivity.orgSee http://vicinity.iot.linkeddata.es/vicinity/testing/report-saref-results.html for the online version of the SAREF ontology requirements.See http://vicinity.iot.linkeddata.es/vicinity/testing/report-ssn-results.html for the online version of the SSN ontology requirements.See http://vicinity.iot.linkeddata.es/vicinity/testing/report-ocf-results.html for the online version of the OCF requirements.See http://vicinity.iot.linkeddata.es/vicinity/testing/report-onem2m-results.html for the online version of the One2M2M ontology requirements.See http://vicinity.iot.linkeddata.es/vicinity/testing/report-isoiec30141-results.html for the online version of the ISO IEC 30141 ontology requirements.See http://vicinity.iot.linkeddata.es/vicinity/conformance.html for the online version of the requirements and tests related to the IoT standards.http://vicinity.iot.linkeddata.es/test